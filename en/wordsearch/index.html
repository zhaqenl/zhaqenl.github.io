<!DOCTYPE html>
<html lang="en"><head><title>Word Search in Python</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><meta content="Word Search in Python" name="description" /><meta content="python, word search, wordsearch, puzzle, implementation, solver" name="keywords" /><meta content="Word Search in Python" property="og:title" /><meta content="article" property="og:type" /><meta content="https://zhaqenl.github.io/en/wordsearch/" property="og:url" /><meta content="https://avatars0.githubusercontent.com/u/29517051" property="og:image" /><link href="/static/ico/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180" /><link href="/static/ico/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png" /><link href="/static/ico/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png" /><link href="/static/ico/manifest.json" rel="manifest" /><link color="#5bbad5" href="/static/ico/safari-pinned-tab.svg" rel="mask-icon" /><meta content="#ffffff" name="theme-color" /><style media="all" type="text/css">html {    color: #DDD;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    background-color: #2A2A2E;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;    font-weight: bold;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid #DDD;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid #DDD;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid #7F7F7F;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}a:visited,a:hover,a:focus { color:           #2cf; text-decoration: none; }a:link { color:           #d30; text-decoration: none;}a:hover,a:focus {    text-decoration: underline;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>Word Search in Python</h1><p><div class="center">Last updated: September 28, 2018</div></p><p><img src="/pictures/grid.jpg" class="banner" alt="clon" /></p><p>This implementation of word search is, in most part, an experiment. An experiment to see how I utilize a tool, Python, to try and solve the problem of implementing basic word search solving algorithm.</p><h2><a name="toc"></a> Table of contents</h2><ul><li><a href='#what'>What is Word Search?</a></li><li><a href='#how_where'>How and where do we start?</a></li><li><a href='#which'>Which tool do we use?</a></li><li><a href='#install'>Python installation</a><ul><li><a href='#windows'>Windows</a></li><li><a href='#lunix'>Linux and Unix</a></li></ul></li><li><a href='#pap'>Pen and paper</a></li><li><a href='#python'>Onto the Python code!</a><ul><li><a href='#implement'>Implementing the algorithm</a><ul><li><a href='#functions'>Functions</a><ul><li><a href='#matrix'>matrixify</a></li><li><a href='#coordChar'>coord_char</a></li><li><a href='#toWord'>convert&#95;to&#95;word</a></li><li><a href='#base'>find&#95;base&#95;match</a></li><li><a href='#neighbors'>matched_neighbors</a></li><li><a href='#completeLine'>complete_line</a></li><li><a href='#completeMatch'>complete_match</a></li><li><a href='#helper'>find_matches</a></li><li><a href='#main'>wordsearch</a></li></ul></li></ul></li></ul></li><li><a href='#close'>Closing remarks</a></li></ul><h2><a name="what"></a> What is Word Search?</h2><p>Word search is a puzzle we usually see in newspapers, and in some magazines, located along the crossword puzzles. They can be located sometimes in bookstores, around the trivia area, as a standalone puzzle book, in which the sole content is a grid of characters and a set of words per page.</p><p>How a traditional word search puzzle works is, for a given grid of different characters, you have to find the hidden words inside the grid. The word could be oriented vertically, horizontally, diagonally, and also inversely in the previously mentioned directions. After all the words are found, the remaining letters of the grid expose a secret message.</p><p>In some word search puzzles, a limitation exists in the length of the hidden words, in that it should contain more than 2 characters, and the grid should have a fixed size of 10 x 10, or an equivalent length and width proportion (which this python implementation doesn’t have).</p><h2><a name="how_where"></a> How and where do we start?</h2><p>Before going deeper into the computer side of the algorithm, let’s first clarify how we tend to solve a word search puzzle:</p><ul><li>We look at a hidden word and its first letter then we proceed to look for the first letter  inside the grid of letters.</li><li>Once we successfully find the first letter of the hidden word inside the grid, we then check the  neighboring characters of that successful match and check whether the second letter of our word  matches any of the neighbors of the successful match.</li><li>After confirming a successful match for the second letter of the hidden word through its  neighbors, we proceed to a much narrower step. After the successful matching of the second letter  of the word in the successful second match’s neighbors, we then follow-through to a straight line  from there, hoping to get a third match (and so on) of the hidden word’s letters.</li></ul><h2><a name="which"></a> Which tool do we use?</h2><p>To realize this series of steps in solving a word search puzzle, we will utilize a programming language known for having a syntax similar to pseudo-code—Python.</p><p>There are two main versions of Python—versions 2.x and 3.x. For this project, we would be utilizing version 2.7.</p><h2><a name="install"></a> Python installation</h2><p>For the installation part, we’ll be covering installation instructions for both Windows, Unix, and Linux.</p><h3><a name="windows"></a> Windows</h3><p>First, determine whether you’re running a 32- or 64-bit operating system. To do that, click Start, right-click Computer, then click Properties. You should see whether you’re running on 32-bit or 64-bit under System type. If you’re running on 32-bit, click on this <a href='https://www.python.org/ftp/python/2.7.15/python-2.7.15.msi'>link</a> then start the download; if you’re on 64-bit, click <a href='https://www.python.org/ftp/python/2.7.15/python-2.7.15.amd64.msi'>this one</a>. Again, take note that we will be utilizing version 2.7 of Python.</p><h3><a name="lunix"></a> Linux and Unix</h3><p>Download this <a href='https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tgz'>file</a> then extract. After extraction, go inside the extracted directory then run the following:</p><pre><code>$ ./configure
$ make
$ make install
</code></pre><p>In Linux/Unix, to make sure that we can actually run Python when we enter the <code>python</code> command in a terminal, let’s make sure that the installed Python files can be located by the system.</p><p>Type the following, then press Enter on your corresponding shell:</p><p>Bash:</p><p><code>export PATH=&quot;$PATH:/usr/local/bin/python&quot;</code></p><p>Sh or Ksh:</p><p><code>PATH=&quot;$PATH:/usr/local/bin/python&quot;</code></p><p>Csh:</p><p><code>setenv PATH &quot;$PATH:/usr/local/bin/python&quot;</code></p><p>For Windows, open your command prompt then type then enter the following command:</p><p><code>path %path%;C:\Python</code></p><h2><a name="pap"></a> Pen and paper</h2><p>As problems go in software development or in programming in general, it is better to tackle the problem with a clear head—going at it with the problem statement and constraints clear in our minds. What we are going to do first is to outline the initial crucial steps in a word search puzzle.</p><p>First, write the word <code>dog</code>, then on the space immediately below it, draw a grid of characters on the paper, like the following:</p><pre><code>dog

d o g g
o o g o
g o g d
</code></pre><p>To start the hunt, we look at the first letter of the word <code>dog</code>, which is the letter <code>d</code>. If, somehow, the first letter of <code>dog</code> doesn’t exist within the grid, it means that we won’t be able to find the word in it! If we successfully find a character match for the first letter of <code>dog</code>, we then proceed to look at the second letter of <code>dog</code>. This time, we are now restricted to look around among the adjacent letters of the first letter match. If the second letter of <code>dog</code> can’t be located around the adjacent letters of <code>d</code> inside the grid, this means that we have to proceed to the next occurrence of the letter <code>d</code> inside the grid.</p><p>If we find a successful match around the adjacent letters of the next occurrence of <code>d</code> inside the grid, then the next steps are literally straightforward. For example:</p><pre><code>      &#42;
      o 
      d
</code></pre><p>In the previous grid, the first letter <code>d</code> matched on the corner of the grid, and the word’s second letter <code>o</code> which is adjacent to <code>d</code>, also successfully matched. If that’s the case, the next location in the grid to check for the subsequent matches of the remaining letters of the word <code>dog</code>, will now be in a straight line with the direction drawn from the first letter to the second letter. In this case, we will check the letter directly above <code>o</code> for the third letter of the word <code>dog</code>, which is <code>g</code>. If instead of the asterisk, the grid showed:</p><pre><code>      d
      o 
      d
</code></pre><p>This means that we don’t have a match, and we should be progressing along the grid through going to the next occurrenct of the first letter. If the asterisk is replaced by the correct missing letter:</p><pre><code>      g
      o 
      d
</code></pre><p>We have a match! However, for our version of word search, we will not stop there. Instead, we will count for all the adjacent letters of the letter <code>d</code>, then look for the matches of the letter <code>o</code>! For example, if we are presented with the following grid:</p><pre><code>  g   g
    o o 
      d
</code></pre><p>Then so far, for the word <code>dog</code>, we found 2 matches! After all the neighbors of the letter <code>d</code> have been checked for a possible match, we then move to the next occurrence of the letter in the grid.</p><h2><a name="python"></a> Onto the Python code!</h2><h3><a name="implement"></a> Implementing the algorithm</h3><p>With the basic algorithm in mind, we can now start implementing the algorithm from the <a href='#pap'>previous</a> section.</p><h4><a name="functions"></a> Functions</h4><h5><a name="matrix"></a> matrixify</h5><pre><code>def matrixify&#40;grid, separator='\n'&#41;:
    return grid.split&#40;separator&#41;
</code></pre><p>The purpose of this function is to return a list whose elements are lines of string. This provides us the ability to index individual elements of the grid through accessing them by their row and column indices:</p><pre><code>&gt;&gt;&gt; grid = 'dogg oogo gogd'
&gt;&gt;&gt; matrix = matrixify&#40;grid, ' '&#41;
&#91;'dogg', 'oogo', 'gogd'&#93;
&gt;&gt;&gt; matrix&#91;1&#93;&#91;2&#93;
'g'
</code></pre><h5><a name="coordChar"></a> coord_char</h5><pre><code>def coord&#95;char&#40;coord, matrix&#41;:
    row&#95;index, column&#95;index = coord
    return matrix&#91;row&#95;index&#93;&#91;column&#95;index&#93;
</code></pre><p>Given a coordinate ((row<i>index, column</i>index) structure) and the matrix where this coordinate is supposedly located in, this function returns the element located at that row and column:</p><pre><code>&gt;&gt;&gt; matrix
&#91;'dogg', 'oogo', 'gogd'&#93;
&gt;&gt;&gt; coord&#95;char&#40;&#40;0, 2&#41;, matrix&#41;
'g'
</code></pre><h5><a name="toWord"></a> convert&#95;to&#95;word</h5><pre><code>def convert&#95;to&#95;word&#40;coord&#95;matrix, matrix&#41;:
    return ''.join&#40;&#91;coord&#95;char&#40;coord, matrix&#41; for coord in coord&#95;matrix&#93;&#41;
</code></pre><p>This function will run through a list of coordinates through a <code>for</code> loop and gets the single length strings using <code>coord&#95;char</code>:</p><pre><code>&gt;&gt;&gt; &#91;coord&#95;char&#40;coord, matrix&#41; for coord in &#91;&#40;0, 0&#41;, &#40;0, 1&#41;, &#40;0, 2&#41;&#93;&#93;
&#91;'d', 'o', 'g'&#93;
</code></pre><p>and then uses the <code>join&#40;&#41;</code> method of strings to return one single string. The <code>''</code> before the <code>join&#40;&#41;</code> method is the separator to use in between the strings, but in our case, we want one single word so we used an empty string separator.</p><h5><a name="base"></a> find&#95;base&#95;match</h5><pre><code>def find&#95;base&#95;match&#40;char, matrix&#41;:
    
    base&#95;matches = &#91;&#40;row&#95;index, column&#95;index&#41; for row&#95;index, row in enumerate&#40;matrix&#41;
                    for column&#95;index, column in enumerate&#40;row&#41;
                    if char == column&#93;

    return base&#95;matches
</code></pre><p>The value of <code>base&#95;matches</code> above is computed by a <code>list comprehension</code>. A list comprehension is just another way of constructing a list, albeit a more concise one. The above list comprehension is roughly equivalent to the following:</p><pre><code>base&#95;matches = &#91;&#93;

for row&#95;index, row in enumerate&#40;matrix&#41;:
    for column&#95;index, column in enumerate&#40;row&#41;:
        if char == column:
            base&#95;matches.append&#40;&#40;row&#95;index, column&#95;index&#41;&#41;
</code></pre><p>I used the <code>enumerate&#40;&#41;</code> function because it appends a counter to an iterable, and that is handy because the counter’s value could correspond to either the row or column indices of the matrix!</p><p>To show that the above code indeed scrolls through the individual characters of <code>grid</code>, let’s modify the body of our <code>for</code> loop in order to display the characters and their corresponding coordinates:</p><pre><code>&gt;&gt;&gt; for row&#95;index, row in enumerate&#40;matrix&#41;:
...    for column&#95;index, column in enumerate&#40;row&#41;:
...        print column, &#40;row&#95;index, column&#95;index&#41;
...
d &#40;0, 0&#41;
o &#40;0, 1&#41;
g &#40;0, 2&#41;
g &#40;0, 3&#41;
o &#40;1, 0&#41;
o &#40;1, 1&#41;
g &#40;1, 2&#41;
o &#40;1, 3&#41;
g &#40;2, 0&#41;
o &#40;2, 1&#41;
g &#40;2, 2&#41;
d &#40;2, 3&#41;
</code></pre><p>Giving our function <code>find&#95;base&#95;match</code> the arguments <code>d</code> and <code>grid</code>, respectively, we get the following:</p><pre><code>&gt;&gt;&gt; find&#95;base&#95;match&#40;'d', grid&#41;
&#91;&#40;0, 0&#41;, &#40;2, 3&#41;&#93;
</code></pre><p>As you can see from the previous <code>for</code> loop output, the coordinates output by our function are indeed the coordinates where the character <code>d</code> matched!</p><p>By calling this function, we can determine whether or not to continue with the further steps. If we deliberately give <code>find&#95;base&#95;match</code> a character that is not inside <code>grid</code>, like <code>c</code>:</p><pre><code>&gt;&gt;&gt; find&#95;base&#95;match&#40;'c', grid&#41;
&#91;&#93;
</code></pre><p>The function returns an empty list! This means, that inside the encompassing function that will call <code>find&#95;base&#95;match</code>, one of the conditions could be:</p><pre><code>if not find&#95;base&#95;match&#40;char, grid&#41;:
    pass
</code></pre><h5><a name="neighbors"></a> matched_neighbors</h5><pre><code>def matched&#95;neighbors&#40;coord, second&#95;char, matrix, row&#95;length, column&#95;length&#41;:
    row&#95;number, column&#95;number = coord
    neighbors&#95;coordinates = &#91;&#40;row, column&#41; for row in xrange&#40;row&#95;number - 1, row&#95;number + 2&#41;
                             for column in xrange&#40;column&#95;number - 1, column&#95;number + 2&#41;
                             if row&#95;length &gt; row &gt;= 0 and column&#95;length &gt; column &gt;= 0
                             and coord&#95;char&#40;&#40;row, column&#41;, matrix&#41; == second&#95;char
                             and not &#40;row, column&#41; == coord&#93;

    return neighbors&#95;coordinates
</code></pre><p>This function finds the adjacent coordinates of the given coordinate, wherein the character of that adjacent coordinate matches the <code>second&#95;char</code> argument!</p><p>Inside <code>neighbors&#95;coordinates</code>, we’re trying to create a list of all the coordinates adjacent the one we gave, but with some conditions to further filter the resulting coordinate:</p><pre><code>&#91;&#40;row, column&#41; for row in xrange&#40;row&#95;number - 1, row&#95;number + 2&#41;
for column in xrange&#40;column&#95;number - 1, column&#95;number + 2&#41;
if row&#95;length &gt; row &gt;= 0 and column&#95;length &gt; column &gt;= 0
and coord&#95;char&#40;&#40;row, column&#41;, matrix&#41; == second&#95;char
and not &#40;row, column&#41; == coord&#93;
</code></pre><p>In the above code snippet, we are creating a list of adjacent coordinates (through <code>&#40;row, column&#41;</code>). Because we want to get the immediate neighbors of a certain coordinate, we deduct 1 from our starting range then add 2 to our end range, so that, if given a row of 0, we will be iterating through <code>xrange&#40;-1, 2&#41;</code>. Remember that the <code>range&#40;&#41;</code> and <code>xrange&#40;&#41;</code> functions is not inclusive of the end range, which means that it doesn’t include the end range in the iteration (hence, the 2 that we add at the end range, not only 1):</p><pre><code>&gt;&gt;&gt; list&#40;xrange&#40;-1, 2&#41;&#41;
&#91;-1, 0, 1&#93;
</code></pre><p>We do the same to the column variable, then later, we filter the contents of the final list through an <code>if</code> clause inside the list comprehension. We do that because we don’t want this function to return coordinates that are out of bounds of the matrix. </p><p>To further hit the nail in the coffin, we also give this function a character as its second argument. That is because we want to further filter the resulting coordinate. We only want a coordinate whose string equivalent matches the second character argument that we give the function!</p><p>If we want to get the neighbors of the coordinate <code>&#40;0, 0&#41;</code>, whose adjacent character in the matrix should be <code>c</code>, call this function with <code>&#40;0, 0&#41;</code> as the first argument, the string <code>c</code> as the second, the matrix itself, and the matrix’s row length and column length, respectively:</p><pre><code>&gt;&gt;&gt; matched&#95;neighbors&#40;&#40;0, 0&#41;, 'c', matrix, 4, 3&#41;
&#91;&#93;
</code></pre><p>Notice that it returns an empty list, because in the neighbors of the coordinate <code>&#40;0, 0&#41;</code>, there is no coordinate in there that has the string <code>c</code> as its string equivalent!</p><p>If we replace <code>c</code> with <code>a</code>:</p><pre><code>&gt;&gt;&gt; matched&#95;neighbors&#40;&#40;0, 0&#41;, 'a', matrix, 4, 3&#41;
&#91;&#40;0, 1&#41;, &#40;1, 0&#41;, &#40;1, 1&#41;&#93;
</code></pre><p>This function returns a list of the adjacent coordinates that match the given character.</p><h5><a name="completeLine"></a> complete_line</h5><pre><code>def complete&#95;line&#40;base&#95;coord, targ&#95;coord, word&#95;len, row&#95;length, column&#95;length&#41;:
    if word&#95;len == 2:
        return base&#95;coord, targ&#95;coord

    line = &#91;base&#95;coord, targ&#95;coord&#93;
    diff&#95;1, diff&#95;2 = targ&#95;coord&#91;0&#93; - base&#95;coord&#91;0&#93;, targ&#95;coord&#91;1&#93; - base&#95;coord&#91;1&#93;

    for &#95; in xrange&#40;word&#95;len - 2&#41;:
        line += &#91;&#40;line&#91;-1&#93;&#91;0&#93; + diff&#95;1, line&#91;-1&#93;&#91;1&#93; + diff&#95;2&#41;&#93;

    if  0 &lt;= line&#91;-1&#93;&#91;0&#93; &lt; row&#95;length and 0 &lt;= line&#91;-1&#93;&#91;1&#93; &lt; column&#95;length:
        return line

    return &#91;&#93;
</code></pre><p>We are now at the stage where functions seem a bit hairier to comprehend! I will attempt to discuss the thoughts I had before creating this function.</p><p>In the <a href='#pap'>Pen and paper</a> section, after matching the first and second letters of the word inside the matrix, I mentioned that the next matching steps become narrower. It becomes narrower in the sense that, after matching the first and second letters of the word, the only thing you need to do after that is to go straight in the direction that the first and second letters created.</p><p>For example:</p><pre><code>      
      o 
      d
</code></pre><p>In the above grid, once the letters <code>d</code> and <code>o</code> are found, one only need to go straight in a line from the first letter <code>d</code> to the second letter <code>o</code>, then take the direction that <code>d</code> took to get to <code>o</code>. In this case, we go upwards of <code>o</code> to check for the third letter match:</p><pre><code>      &#42; &lt;- Check this next.
      o 
      d
</code></pre><p>Another example:</p><pre><code>
  o
d
</code></pre><p>The direction that the above matches create is north-east. This means that we have to check the place north-east of 'o':</p><pre><code>    &#42; &lt;- This one.
  o
d
</code></pre><p>With that being said, I wanted a function to give me all the coordinates forming a straight line, when given two coordinates.</p><p>The first problem I had to solve was—Given two coordinates, how do I compute the coordinate of the third one, which will later form a straight line in the matrix? </p><p>To solve this problem, I tried plotting all the expected goal coordinates, if for example, the first coordinate match is <code>&#40;1, 1&#41;</code> and the second coordinate match is <code>&#40;0, 0&#41;</code>:</p><pre><code>first     &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41;
second    &#40;0, 0&#41; &#40;0, 1&#41; &#40;0, 2&#41; &#40;1, 2&#41; &#40;2, 2&#41; &#40;2, 1&#41; &#40;2, 0&#41; &#40;1, 0&#41;
expected &#40;-1,-1&#41;&#40;-1, 1&#41;&#40;-1, 3&#41; &#40;1, 3&#41; &#40;3, 3&#41; &#40;3, 1&#41; &#40;3,-1&#41; &#40;1,-1&#41;
</code></pre><p>While looking at the above plot, an idea came into my mind. What I wanted to get was the amount of step needed to go from the second coordinate to the third. In hopes of achieving that, I tried subtracting the row and column values of the first from the second:</p><pre><code>second    &#40;0, 0&#41; &#40;0, 1&#41; &#40;0, 2&#41; &#40;1, 2&#41; &#40;2, 2&#41; &#40;2, 1&#41; &#40;2, 0&#41; &#40;1, 0&#41;
first     &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41; &#40;1, 1&#41;
diff     &#40;-1,-1&#41;&#40;-1, 0&#41;&#40;-1, 1&#41; &#40;0, 1&#41; &#40;1, 1&#41; &#40;1, 0&#41; &#40;1,-1&#41; &#40;0,-1&#41;
</code></pre><p>After that, I tried adding the values of the <code>diff</code> row to the values of <code>second</code>:</p><pre><code>second    &#40;0, 0&#41; &#40;0, 1&#41; &#40;0, 2&#41; &#40;1, 2&#41; &#40;2, 2&#41; &#40;2, 1&#41; &#40;2, 0&#41; &#40;1, 0&#41;
diff     &#40;-1,-1&#41;&#40;-1, 0&#41;&#40;-1, 1&#41; &#40;0, 1&#41; &#40;1, 1&#41; &#40;1, 0&#41; &#40;1,-1&#41; &#40;0,-1&#41;
sum      &#40;-1,-1&#41;&#40;-1, 1&#41;&#40;-1, 3&#41; &#40;1, 3&#41; &#40;3, 3&#41; &#40;3, 1&#41; &#40;3,-1&#41; &#40;1,-1&#41;
</code></pre><p>If you look closely, the values of the <code>sum</code> row match those of the <code>expected</code> row! To summarize, I get the difference by subracting values of the first coordinate from the values of the second coordinate, then I add the difference to the second coordinate to arrive at the expected third!</p><p>Now, back to the function:</p><pre><code>def complete&#95;line&#40;base&#95;coord, targ&#95;coord, word&#95;len, row&#95;length, column&#95;length&#41;:
    if word&#95;len == 2:
        return base&#95;coord, targ&#95;coord

    line = &#91;base&#95;coord, targ&#95;coord&#93;
    diff&#95;1, diff&#95;2 = targ&#95;coord&#91;0&#93; - base&#95;coord&#91;0&#93;, targ&#95;coord&#91;1&#93; - base&#95;coord&#91;1&#93;

    for &#95; in xrange&#40;word&#95;len - 2&#41;:
        line += &#91;&#40;line&#91;-1&#93;&#91;0&#93; + diff&#95;1, line&#91;-1&#93;&#91;1&#93; + diff&#95;2&#41;&#93;

    if  0 &lt;= line&#91;-1&#93;&#91;0&#93; &lt;= row&#95;length and 0 &lt;= line&#91;-1&#93;&#91;1&#93; &lt;= column&#95;length:
        return line

    return &#91;&#93;
</code></pre><p>For this function, however, I decided pass it the length of the word as an argument for mainly two reasons—to check for double length words, and for the length of the final list output. We check for double length words because with words that have lengths of 2, we no longer need to compute for a third coordinate because the word only needs two coordinates to be complete.</p><p>For the second reason, this serves as the quirk of my algorithm. Instead of checking the third coordinate for a match of the third character (and the subsequent ones), I instead create a list of coordinates, forming a straight line in the matrix, whose length is equal to the length of the word.</p><p>I first create the <code>line</code> variable which already contains the coordinates of the first match and the second match of the word. After that, I get the difference of the second coordinates values and the first. Finally, I create a <code>for</code> loop whose loop count is the length of the word minus 2 (because <code>line</code> already has two values inside). Inside the loop, I append to the <code>line</code> list variable a new coordinate by getting <code>line</code>’s last variable values then adding the difference of the second and first match coordinates.</p><p>Finally, to make sure that the created coordinate list can be found inside the matrix, I check the last coordinate of the <code>line</code> variable if it’s within the bounds of the matrix. If it is, I return the newly created coordinate list, and if not, I simply return an empty list.</p><p>Let’s say we want a complete line when given coordinate matches <code>&#40;0, 0&#41;</code> and <code>&#40;1, 1&#41;</code>, and the length of our word is 3:</p><pre><code>&gt;&gt;&gt; core.complete&#95;line&#40;&#40;0, 0&#41;, &#40;1, 1&#41;, 3, 4, 3&#41;
&#91;&#40;0, 0&#41;, &#40;1, 1&#41;, &#40;2, 2&#41;&#93;
</code></pre><p>If we give the function a word length of 4:</p><pre><code>&gt;&gt;&gt; core.complete&#95;line&#40;&#40;0, 0&#41;, &#40;1, 1&#41;, 4, 4, 3&#41;
&#91;&#93;
</code></pre><p>it returns an empty list because the last coordinate of the created list went out of bounds.</p><h5><a name="completeMatch"></a> complete_match</h5><pre><code>def complete&#95;match&#40;word, matrix, base&#95;matches, word&#95;len, row&#95;length, column&#95;length&#41;:
    match&#95;candidates = &#40;complete&#95;line&#40;base, neighbor, word&#95;len, row&#95;length, column&#95;length&#41;
                       for base in base&#95;matches
                       for neighbor in matched&#95;neighbors&#40;base, word&#91;1&#93;, matrix, row&#95;length,
                                                         column&#95;length&#41;&#41;

    return &#91;match for match in match&#95;candidates if convert&#95;to&#95;word&#40;match, matrix&#41; == word&#93;
</code></pre><p>This is the <code>complete&#95;line</code> function on steroids. The goal of this function is to apply <code>complete&#95;line</code> to all the neighbors of the first match. After that, it creates a lists of coordinates whose word equivalent is the same as the word we’re trying to look for inside the matrix.</p><p>For the value of the <code>match&#95;candidates</code> variable, I utilize a generator comprehension. These are like list comprehensions, except, they release their values one by one, only upon request, in contrast to list comprehensions which return all the contents of the list in one go.</p><p>To accomplish the application of <code>complete&#95;line</code> to all the neighbors of the first match, I iterate through all the first matches:</p><p><code>for base in base&#95;matches</code></p><p>then inside that <code>for</code> loop, I iterate through all the neighbors that <code>matched&#95;neighbors</code> gave us:</p><p><code>for neighbor in matched&#95;neighbors&#40;base, word&#91;1&#93;, matrix, row&#95;length, column&#95;length&#41;</code></p><p>I then put the following statement in the first part of the generator comprehension:</p><p><code>complete&#95;line&#40;base, neighbor, word&#95;len, row&#95;length, column&#95;length&#41;</code></p><p>The above generator comprehension is roughly equivalent to:</p><pre><code>for base in base&#95;matches:
    for neighbor in matched&#95;neighbors&#40;base, word&#91;1&#93;, matrix, row&#95;length, column&#95;length&#41;:
        yield complete&#95;line&#40;base, neighbor, word&#95;len, row&#95;length, column&#95;length&#41;
</code></pre><p>After the creation of the <code>match&#95;candidates</code> variable, we now start going through its values one by one:</p><p><code>&#91;match for match in match&#95;candidates if convert&#95;to&#95;word&#40;match, matrix&#41; == word&#93;</code></p><p>This list comprehension above will filter the <code>match&#95;candidates</code> and the resulting list will only contain coordinates that, when converted to its word counterpart, match the original word we wanted to find.</p><p>Attempting to find the word <code>dog</code> inside our matrix returns a list of lists containing matched coordinates:</p><pre><code>&gt;&gt;&gt; core.complete&#95;match&#40;'dog', matrix, find&#95;base&#95;match&#40;'dog'&#91;0&#93;, matrix&#41;, 3, 3, 4&#41;
&#91;&#91;&#40;0, 0&#41;, &#40;0, 1&#41;, &#40;0, 2&#41;&#93;, &#91;&#40;0, 0&#41;, &#40;1, 0&#41;, &#40;2, 0&#41;&#93;, &#91;&#40;0, 0&#41;, &#40;1, 1&#41;, &#40;2, 2&#41;&#93;, &#91;&#40;2, 3&#41;, &#40;1, 3&#41;, &#40;0, 3&#41;&#93;&#93;
</code></pre><h5><a name="helper"></a> find_matches</h5><pre><code>def find&#95;matches&#40;word, grid, separator='\n'&#41;:
    word&#95;len = len&#40;word&#41;
    matrix = matrixify&#40;grid, separator&#41;
    row&#95;length, column&#95;length = len&#40;matrix&#41;, len&#40;matrix&#91;0&#93;&#41;
    base&#95;matches = find&#95;base&#95;match&#40;word&#91;0&#93;, matrix&#41;

    if column&#95;length &lt; word&#95;len &gt; row&#95;length or not base&#95;matches:
        return &#91;&#93;
    elif word&#95;len == 1:
        return base&#95;matches

    return complete&#95;match&#40;word, matrix, base&#95;matches, word&#95;len, row&#95;length, column&#95;length&#41;
</code></pre><p>This function will serve as the helper of our main function. Its ultimate goal is to output a list containing the coordinates of all the possible matches of <code>word</code> inside <code>grid</code>. For general purposes, I defined four variables:</p><ul><li>The <code>word&#95;len</code> variable whose value is the length of the <code>word</code> argument, which will generally be  useful throughout the script</li><li>The <code>matrix</code> variable whose value we get through giving  <code>grid</code> to our <code>matrixify</code> function, which will allow us to later be able to index contents of the  matrix through its row and column indices. </li><li>The <code>row&#95;length</code> and the <code>column&#95;length</code> variable of <code>matrix</code></li><li><code>base&#95;matches</code> which contain the coordinates of all the first letter matches of <code>word</code></li></ul><p>After the variables, we will do some sanity checks:</p><pre><code>if column&#95;length &lt; word&#95;len &gt; row&#95;length or not base&#95;matches:
        return &#91;&#93;
elif word&#95;len == 1:
        return base&#95;matches
</code></pre><p>The above <code>if elif</code> statement will check if the length of <code>word</code> is longer than both the <code>column&#95;length</code> and <code>row&#95;length</code> and also checks if <code>base&#95;matches</code> returns an empty list. If that condition is not satisfied, it means that <code>word</code> can fit inside the matrix, and <code>base&#95;matches</code> found a match! However, if the length of <code>word</code> is 1, we simply return <code>base&#95;matches</code>.</p><p>If the word is longer than 1, we then pass the local variables to <code>complete&#95;match</code> for further processing.</p><p>Given <code>dog</code>, the string chain <code>dogg oogo gogd</code>, and the <code>' '</code> separator as arguments:</p><pre><code>&gt;&gt;&gt; find&#95;matches&#40;'dog', 'dogg oogo gogd', ' '&#41;
&#91;&#91;&#40;0, 0&#41;, &#40;0, 1&#41;, &#40;0, 2&#41;&#93;, &#91;&#40;0, 0&#41;, &#40;1, 0&#41;, &#40;2, 0&#41;&#93;, &#91;&#40;0, 0&#41;, &#40;1, 1&#41;, &#40;2, 2&#41;&#93;, &#91;&#40;2, 3&#41;, &#40;1, 3&#41;,
&#40;0, 3&#41;&#93;&#93;
</code></pre><p>Voila! This is the list, which contain lists of coordinates where the word <code>dog</code> matched inside <code>dogg oogo gogd</code>!</p><h5><a name="main"></a> wordsearch</h5><pre><code>def wordsearch&#40;word, string&#95;grid, separator='\n'&#41;:
    return len&#40;find&#95;matches&#40;word, string&#95;grid, separator&#41;&#41;
</code></pre><p>This function simply returns the number of matches of running <code>find&#95;matches&#40;word, string&#95;grid, separator='\n'&#41;</code>:</p><pre><code>&gt;&gt;&gt; wordsearch&#40;'dog', 'dogg oogo gogd', ' '&#41;
4
</code></pre><p>There are 4 matches of <code>dog</code> inside <code>dogg oogo gogd</code>!</p><h2><a name="close"></a> Closing remarks</h2><p>Remember, it’s never a bad idea to go back to using pen and paper to solve programming problems. Sometimes, we express ideas better using our bare hands, and to top it off, a good ’ol break from the monitor and from the walls of code could just be what you need for a breakthrough—just like when I got stuck thinking about how I should implement my <a href='#completeLine'>complete_line</a> function!</p><hr/><div class="footer"><p><div class="text-small"> <a href='/en'>Home</a> · <a href='/en/about'>About</a> · <a href='https://github.com/zhaqenl/zhaqenl.github.io'>Source</a> </div> <div class="text-x-small"> Created with <a href='https://github.com/ebzzry/emem'>emem</a> <div></p><p><div class="text-x-small"> <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/deed.en"><img alt="CC0 1.0 Universal (CC0 1.0) Public Domain Dedication" class="cc" src="/pictures/cc0-88x31.png" /></a><br> This work is in the <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/deed.en">public domain.</a><br> </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-121960562-1', 'auto');ga('send', 'pageview');</script></body></html>