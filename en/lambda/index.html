<!DOCTYPE html>
<html lang="en"><head><title>The Surface of Lambda Calculus</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><meta content="The Surface of Lambda Calculus" name="description" /><meta content="lambda, calculus, alonzo, church" name="keywords" /><meta content="The Surface of Lambda Calculus" property="og:title" /><meta content="article" property="og:type" /><meta content="https://zhaqenl.github.io/en/lambda/" property="og:url" /><meta content="https://avatars0.githubusercontent.com/u/29517051" property="og:image" /><link href="/static/ico/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180" /><link href="/static/ico/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png" /><link href="/static/ico/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png" /><link href="/static/ico/manifest.json" rel="manifest" /><link color="#5bbad5" href="/static/ico/safari-pinned-tab.svg" rel="mask-icon" /><meta content="#ffffff" name="theme-color" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;    font-weight: bold;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>The Surface of Lambda Calculus</h1><p><div class="center">Last updated: July 16, 2018</div></p><p><img src="/pictures/half-lambda.png" class="banner" alt="half-lambda" /> <div style="text-align: right"> <i>Image by Lapse via <a href='https://whvn.cc/32786'>wallhaven</a></i> </div></p><p>In this short guide, I will discuss how I understood Lambda Calculus through the online journal entry of <i>ebzzry</i> titled <a href='https://ebzzry.io/en/lambda-calculus/'>A Lambda Calculus Primer</a>.</p><h2>Table of Contents</h2><ul><li><a href='#what'>What is lambda calculus?</a></li><li><a href='#where'>Where do we start?</a></li><li><a href='#how'>How to apply lambda calculus functions</a><ul><li><a href='#numbers'>Numbers</a></li></ul></li><li><a href='#advanced'>The advanced functions</a><ul><li><a href='#successor'>Successor</a></li><li><a href='#addition'>Addition</a></li><li><a href='#multiplication'>Multiplication</a></li><li><a href='#boolean'>Boolean functions</a></li><li><a href='#aon'>And or Not?</a></li><li><a href='#predecessor'>Predecessor</a></li></ul></li></ul><h2><a name="what"></a> What is lambda calculus?</h2><p>Lambda Calculus, simply, is a <i>standard</i> method of expressing computations.</p><h2><a name="where"></a> Where do we start?</h2><p>Before we proceed to the <i>meat</i> of the topic, we need to define <i>terms</i> that we'll use throughout this documentation. A <i>function</i> is a piece of code that when executed or <i>called</i>, performs a task. This is what a <i>basic</i> function in lambda calculus looks like:</p><pre><code>&#40;λa.a&#41;
</code></pre><p>In lambda calculus, this is what they call an <i>identity function</i> and I'll discuss later a bit of what it does and how it works. Let's dissect a bit what is contained within a lambda calculus function. The <code>λ</code>, which is a Greek letter meaning <i>lambda</i>, indicates that whatever is after it is a function. The letter or symbol after the <code>λ</code> preceding the <code>.</code> is the parameter or the name of the function, and the succeeding letter or symbol after the <code>.</code> is the body of the function. Symbols that reside between the <code>λ</code> and <code>.</code> are called <i>bound</i> and I'll show you in the next section how these <i>bound</i> things behave.</p><h2><a name="how"></a> How to apply lambda calculus functions</h2><p>We will start with something simple and we'll use the <i>identity function</i> to demonstrate how function applications work in lambda calculus.</p><pre><code>&#40;λa.a&#41;b
</code></pre><p>The output of the function application above is <code>b</code>. Why, you ask? Let's break it down. The <code>b</code> in the snippet above is what the <i>identity function</i> is applied to. In lambda calculus, what we do is we substitute the <code>b</code> for the first bound variable after the <code>λ</code> symbol which is <code>a</code>. After the substitution, which will consume the <code>a</code>, we also substitute <code>b</code> for every occurrence of the symbol <code>a</code> that appears in the function body which will result in the output <code>b</code>. Let's take a small step forward to attempt to possibly clarify this <i>application</i>.</p><pre><code>&#40;λba.b&#41;r
</code></pre><p>In the snippet above, we will apply the function <code>&#40;λba.b&#41;</code> to <code>r</code> and I won't tell you the output yet so let's walk through the process. The symbols before the <code>.</code> and after the <code>λ</code> are <i>bound</i> but our higher concern is the symbol immediately succeeding the <code>λ</code> symbol which is <code>b</code> because that is what we will be substituting <code>r</code> for. We now substitute <code>r</code> for the bound variable <code>b</code>, therefore consuming it, then we also substitute <code>r</code> for every occurrence of the bound variable we substituted inside the function body, which will result to:</p><pre><code>&#40;λa.r&#41;
</code></pre><p>Last example before we discuss further:</p><pre><code>&#40;λab.a&#40;b&#41;&#41;cd
</code></pre><p>We take <code>c</code> then substitute it for the <i>first</i> bound variable <code>a</code>:</p><pre><code>&#40;λb.c&#40;b&#41;&#41;d
</code></pre><p>We then take <code>d</code> then substitute it for <code>b</code> which will result to:</p><pre><code>cd
</code></pre><h3><a name="numbers"></a> Numbers</h3><p>Before we move to the more complicated functions, let's first establish how numbers are expressed as functions in lambda calculus. As a basis, the number zero is expressed as:</p><pre><code>&#40;λab.b&#41;
</code></pre><p>To get to 1, we simply append a duplicate of the <i>first</i> bound variable which is <code>a</code> immediately after the <code>.</code> which will result to:</p><pre><code>&#40;λab.ab&#41;
</code></pre><h2><a name="advanced"></a> The advanced functions</h2><h3><a name="successor"></a> Successor</h3><p>We'll start first with the Successor function which is defined as:</p><pre><code>&#40;λabc.b&#40;abc&#41;&#41;
</code></pre><p>What this function does is it finds the result after adding one to a whole number. Let's try it with the number two:</p><pre><code>&#40;λabc.b&#40;abc&#41;&#41;2
&#40;λabc.b&#40;abc&#41;&#41;&#40;λde.d&#40;d&#40;e&#41;&#41;&#41;
</code></pre><p>Substitute the first bound variable <code>a</code> with the function for number two:</p><pre><code>&#40;λbc.b&#40;&#40;λde.d&#40;d&#40;e&#41;&#41;&#41;bc&#41;&#41;
</code></pre><p>We now apply the number two function to the <code>bc</code> in the function body:</p><pre><code>&#40;λbc.b&#40;&#40;λe.b&#40;b&#40;e&#41;&#41;&#41;c&#41;&#41;
&#40;λbc.b&#40;b&#40;b&#40;c&#41;&#41;&#41;&#41;
</code></pre><p>The result is now the function for number three.</p><h3><a name="addition"></a> Addition</h3><p>To <i>add</i> in lambda calculus, you just need to modify a little your usage of the <i>successor</i> function. With addition, you position the successor function in between the whole numbers you're trying to add or simply called as an <i>infix</i>, like this:</p><pre><code>1S2
</code></pre><p>You can further <i>reduce</i> it in a way through spelling out the equivalent functional notation which is equivalent to <i>one S (single S)</i> and a 2.</p><pre><code>S2
</code></pre><p>We now do the <i>magic</i> of expansion then reduction:</p><pre><code>S2
&#40;λabc.b&#40;abc&#41;&#41;2
&#40;λbc.b&#40;2bc&#41;&#41;
&#40;λbc.b&#40;&#40;λde.d&#40;d&#40;e&#41;&#41;&#41;bc&#41;&#41;
&#40;λbc.b&#40;&#40;λe.b&#40;b&#40;e&#41;&#41;&#41;c&#41;&#41;
&#40;λbc.b&#40;b&#40;b&#40;c&#41;&#41;&#41;&#41;
= 3
</code></pre><h3><a name="multiplication"></a> Multiplication</h3><p>To <i>multiply</i>, instead of putting the function in between the numbers or as an infix, we'll use a prefix syntax. The multiplication function is defined as:</p><pre><code>&#40;λabc.a&#40;bc&#41;&#41;
</code></pre><p>To multiply two and two, we proceed like this:</p><pre><code>&#40;λabc.a&#40;bc&#41;&#41;22
&#40;λbc.2&#40;bc&#41;&#41;2
&#40;λc.2&#40;2c&#41;&#41;
&#40;λc.&#40;λde.d&#40;d&#40;e&#41;&#41;&#41;&#40;2c&#41;&#41;
&#40;λc.&#40;λde.d&#40;d&#40;e&#41;&#41;&#41;&#40;&#40;λfg.f&#40;f&#40;g&#41;&#41;&#41;c&#41;&#41;
&#40;λc.&#40;λde.d&#40;d&#40;e&#41;&#41;&#41;&#40;λg.c&#40;c&#40;g&#41;&#41;&#41;&#41;
&#40;λc.&#40;λe.&#40;λg.c&#40;c&#40;g&#41;&#41;&#41;&#40;&#40;λg.c&#40;c&#40;g&#41;&#41;&#41;e&#41;&#41;&#41;
&#40;λc.&#40;λe.&#40;λg.c&#40;c&#40;g&#41;&#41;&#41;&#40;c&#40;c&#40;e&#41;&#41;&#41;&#41;&#41;
&#40;λc.&#40;λe.&#40;c&#40;c&#40;c&#40;c&#40;e&#41;&#41;&#41;&#41;&#41;&#41;&#41;
= &#40;λce.c&#40;c&#40;c&#40;c&#40;e&#41;&#41;&#41;&#41;&#41;
= 4
</code></pre><h3><a name="boolean"></a> Boolean functions</h3><p>The true and false functions in lambda calculus are pretty simple:</p><pre><code>True&#40;T&#41; = &#40;λab.a&#41;
False&#40;F&#41; = &#40;λab.b&#41;
</code></pre><p>What the functions above do is when given a pair to be applied to like <code>ab</code> or <code>cd</code>, the <code>true</code> function will result in the first of the pair hence <code>a</code> while the <code>false</code> function will give the second, <code>b</code>. Let's experiment:</p><pre><code>Tsz = &#40;λab.a&#41;sz
&#40;λb.s&#41;z
= s

Fsz = &#40;λab.b&#41;sz
&#40;λb.b&#41;z
= z
</code></pre><h3><a name="aon"></a> And or Not?</h3><p>For these three logical operators, we'll import from the boolean functions:</p><pre><code>And&#40;∧&#41; = λab.ab&#40;λcd.d&#41; = λab.ab&#40;F&#41;
Or&#40;∨&#41; = λab.a&#40;λcd.c&#41;b = λab.a&#40;T&#41;b
Not&#40;¬&#41; = λa.a&#40;λbc.c&#41;&#40;λde.d&#41; = λa.a&#40;F&#41;&#40;T&#41;
</code></pre><p>Let's try the Not function on <code>F</code></p><pre><code>¬F
λa.a&#40;λbc.c&#41;&#40;λde.d&#41;F
λa.a&#40;λbc.c&#41;&#40;λde.d&#41;&#40;λfg.g&#41;
= &#40;λbc.c&#41;&#40;λde.d&#41;&#40;λfg.g&#41;
= FFT
&#40;λbc.c&#41;&#40;λfg.g&#41;&#40;λde.d&#41;
&#40;λc.c&#41;&#40;λde.d&#41;
&#40;λde.d&#41;
= T
</code></pre><h3><a name="predecessor"></a> Predecessor</h3><p>The predecessor function is the function <i>reverse</i> of the successor function because instead of adding 1, you deduct 1 from the whole number you are applying it to.</p><p>Before we proceed to defining the actual predecessor function, we have to <i>define</i> first, in a way, the prerequisite information needed to have a better understanding of how the predecessor function was formed.</p><p>First, you'll be needing a <i>pair</i> which looks like (b, a), but in this pair, the first element is one notch higher than the second element, meaning, the first element <code>b</code> is the successor of the second element <code>a</code> which also means that <code>a</code> is the predecessor of <code>b</code>. With that being said, to determine the predecessor of <code>a</code>, you create a pair like the one previously mentioned, select the second element (which is done by the false boolean function), then it will look like (a, ?).</p><p>A pair in lambda calculus function form looks like:</p><pre><code>&#40;λa.a&#40;bc&#41;&#41;
</code></pre><p>To serve as the base for the final form of the predecessor function, we'll use the zeroth pair:</p><pre><code>&#40;λc.c&#40;00&#41;&#41;
</code></pre><p>One last thing before we proceed to the final form of the predecessor function, we'll define a separate function whose task is to take a pair, then output a new pair, wherein in this new pair, the first element is the successor of the second element:</p><pre><code>Z
&#40;λab.b&#40;S&#40;aT&#41;&#41;&#40;aT&#41;&#41;
</code></pre><p>Let's apply it to our zeroth pair:</p><pre><code>Z&#40;λc.c&#40;00&#41;&#41;
&#40;λab.b&#40;S&#40;aT&#41;&#41;&#40;aT&#41;&#41;&#40;λc.c&#40;00&#41;&#41;
&#40;λab.b&#40;S&#40;aT&#41;&#41;&#40;aT&#41;&#41;&#40;λc.c&#40;&#40;λhi.i&#41;&#40;λhi.i&#41;&#41;&#41;
&#40;λb.b&#40;S&#40;&#40;λc.c&#40;&#40;λhi.i&#41;&#40;λhi.i&#41;&#41;&#41;T&#41;&#41;&#40;&#40;λc.c&#40;&#40;λhi.i&#41;&#40;λhi.i&#41;&#41;&#41;T&#41;&#41;
&#40;λb.b&#40;S&#40;λhi.i&#41;&#41;&#40;λhi.i&#41;&#41;
&#40;λb.b&#40;λhi.h&#40;i&#41;&#40;λhi.i&#41;&#41;&#41;
&#40;λb.b10&#41;
</code></pre><p>We can now build the main predecessor function:</p><pre><code>P
&#40;λa.aZ&#40;λc.c&#40;00&#41;&#41;&#41;F
</code></pre><p>You'll notice that the main difference is that there's a <code>false</code> boolean function appended at the end and that will <i>select</i> the second element from the resulting <i>pair</i> which will be the <i>predecessor</i> element we're looking for. Let's test it on the number one:</p><pre><code>P1
&#40;&#40;λa.aZ&#40;λc.c&#40;00&#41;&#41;&#41;F&#41;1
&#40;1Z&#40;λc.c&#40;00&#41;&#41;&#41;F
&#40;λab.abZ&#40;λc.c&#40;00&#41;&#41;&#41;F
&#40;λab.ab&#40;λab.b&#40;&#40;S&#40;aT&#41;&#41;&#40;aT&#41;&#41;&#41;&#40;λc.c&#40;λrm.m&#41;&#40;λrm.m&#41;&#41;&#41;&#40;λfg.g&#41;
&#40;λb.&#40;λab.b&#40;&#40;S&#40;aT&#41;&#41;&#40;aT&#41;&#41;&#41;&#40;λc.c&#40;λrm.m&#41;&#40;λrm.m&#41;&#41;b&#41;&#40;λfg.g&#41;
&#40;&#40;λab.b&#40;&#40;S&#40;aT&#41;&#41;&#40;aT&#41;&#41;&#41;&#40;λc.c&#40;λrm.m&#41;&#40;λrm.m&#41;&#41;&#41;&#40;λfg.g&#41;
&#40;λb.b&#40;&#40;S&#40;&#40;λc.c&#40;λrm.m&#41;&#40;λrm.m&#41;&#41;T&#41;&#41;&#40;&#40;λc.c&#40;λrm.m&#41;&#40;λrm.m&#41;&#41;T&#41;&#41;&#41;&#40;λfg.g&#41;
&#40;λb.b&#40;&#40;S&#40;λrm.m&#41;&#41;&#40;λrm.m&#41;&#41;&#41;&#40;λfg.g&#41;
&#40;λb.b&#40;&#40;λrm.r&#40;m&#41;&#41;&#40;λrm.m&#41;&#41;&#41;&#40;λfg.g&#41;
&#40;λfg.g&#41; &#40;&#40;λrm.r&#40;m&#41;&#41;&#40;λrm.m&#41;&#41;
&#40;λg.g&#41;&#40;λrm.m&#41;
&#40;λrm.m&#41;
= 0
</code></pre><p>With the predecessor function being built, the subtraction function can now be formulated:</p><pre><code>R
&#40;λab.bPa&#41;
</code></pre><p>The function above means that the <i>larger</i> element <code>b</code> comes before the <i>smaller</i> element <code>a</code> and in between them is the predecessor function. Let's try it with two and one:</p><pre><code>R21
&#40;λab.bPa&#41;&#40;λcd.c&#40;c&#40;d&#41;&#41;&#41;&#40;λcd.c&#40;d&#41;&#41;
&#40;λb.bP&#40;λcd.c&#40;c&#40;d&#41;&#41;&#41;&#41;&#40;λcd.c&#40;d&#41;&#41;
&#40;λcd.c&#40;d&#41;&#41;&#40;P&#40;λcd.c&#40;c&#40;d&#41;&#41;&#41;&#41;
&#40;λcd.c&#40;d&#41;&#41;&#40;λcd.c&#40;d&#41;&#41;
&#40;λd.&#40;λcd.c&#40;d&#41;&#41;d&#41;
&#40;λcd.c&#40;d&#41;&#41;
= 1
</code></pre><hr/><div class="footer"><p><div class="text-small"> <a href='/en'>Home</a> · <a href='/en/about'>About</a> · <a href='/en/musings'>Musings</a> · <a href='/en/excerpts'>Excerpts</a> · <a href='https://github.com/zhaqenl/zhaqenl.github.io'>Source</a> </div> <div class="text-x-small"> Created with <a href='https://github.com/ebzzry/emem'>emem</a> and <a href='https://github.com/ebzzry/skeleton'>skeleton</a> <div></p><p><div class="text-x-small"> <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/deed.en"><img alt="CC0 1.0 Universal (CC0 1.0) Public Domain Dedication" class="cc" src="/pictures/cc0-88x31.png" /></a><br> This work is in the <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/deed.en">public domain.</a><br> </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-121960562-1', 'auto');ga('send', 'pageview');</script></body></html>